// This file is part of JML

// JML is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.

// JML is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with JML; see the file COPYING.  If not, write to
// the Free Software Foundation, 675 Mass  Ave, Cambridge, MA 02139, USA.

package java.lang;
import java.util.Random;

/** 
 * JML specification for java.lang.Math in Java 1.4.
 *
 * @version OpenJML 1.0
 * @author Brandon Shilling
 * @author David Cok
 * @author Gary T. Leavens
 * @author Daniel M. Zimmerman
 * @author Erik Poll
 * @author Radu Grigore
 */
/* CAUTION: Note that 
    - there is a difference between float/double positive and negative 0
    - primitive == does not distinguish between positive and negative zero
	that is, (+0.0 == -0.0) is true; use isPositiveZero and 
	isNegativeZero when you need to distinguish these
    - NaN compares false to everything: (NaN == NaN) is false; you have to
	use Double.isNaN(\...)
    - primitive == is not the same as .equals on Doubles
    - primitive comparisions (<, >, <=, >=) on doubles are not the same as
	.comparesTo on Doubles
*/
// nullable by default, because we don't know what the implementation
// will do with its random number generator
/*@ nullable_by_default @*/  
public /*@ pure @*/ final class Math {
    /**
     * @design These axioms are used to connect the floating point domain
     * to the integer domain for static analysis tools that don't
     * support floating point.
     **/
    // @+ESC axiom E > 0.0;  
    public static final double E;

    /**
     * @design These axioms are used to connect the floating point domain
     * to the integer domain for static analysis tools that don't
     * support floating point.
     **/
    // @+ESC axiom PI > 0.0; 
    public static final double PI;

    /*@ public normal_behavior 
      @ {|
      @   requires Double.isNaN(a) || Double.isInfinite(a);
      @   ensures Double.isNaN(\result);
      @ also
      @   requires a == 0.0;  // positive or negative zero
      @   ensures \result == 0.0;
      @ also
      @   requires isPositiveZero(a);
      @   ensures isPositiveZero(\result);
      @ also
      @   requires isNegativeZero(a);
      @   ensures isNegativeZero(\result);
      @ also
      @   requires isFinite(a);
      @   ensures (* result within 1 ulp of exact result *);
      @ |}
      @*/
    public static /*@ pure @*/ double sin(double a);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(a) || Double.isInfinite(a);
      @   ensures Double.isNaN(\result);
      @ also
      @   requires a == 0.0;  // positive or negative zero
      @   ensures \result == 1.0;
      @ also
      @   requires isFinite(a);
      @   ensures (* result within 1 ulp of exact result *);
      @ |}
      @*/
    public static /*@ pure @*/ double cos(double a);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(a) || Double.isInfinite(a);
      @   ensures Double.isNaN(\result);
      @ also
      @   requires a == 0.0;  // positive or negative zero
      @   ensures \result == 0.0;
      @ also
      @   requires isPositiveZero(a);
      @   ensures isPositiveZero(\result);
      @ also
      @   requires isNegativeZero(a);
      @   ensures isNegativeZero(\result);
      @ also
      @   requires isFinite(a);
      @   ensures (* result within 1 ulp of exact result *);
      @ |}
      @*/
    public static /*@ pure @*/ double tan(double a);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(a) || abs(a) > 1;
      @   ensures Double.isNaN(\result);
      @ also
      @   requires a == 0.0;  // positive or negative zero
      @   ensures \result == 0.0;
      @ also
      @   requires isPositiveZero(a);
      @   ensures isPositiveZero(\result);
      @ also
      @   requires isNegativeZero(a);
      @   ensures isNegativeZero(\result);
      @ also
      @   requires !Double.isNaN(a) && abs(a) <= 1;
      @   ensures -PI/2 <= \result && \result <= PI/2;
      @   ensures (* result within 1 ulp of exact result *);
      @ |}
      @*/
    public static /*@ pure @*/ double asin(double a);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(a) || abs(a) > 1;
      @   ensures Double.isNaN(\result);
      @ also
      @   requires !Double.isNaN(a) && abs(a) <= 1;
      @   ensures -PI/2 <= \result && \result <= PI/2;
      @   ensures (* result within 1 ulp of exact result *);
      @ |}
      @*/
    public static /*@ pure @*/ double acos(double a);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(a);
      @   ensures Double.isNaN(\result);
      @ also
      @   requires a == 0.0;  // positive or negative zero
      @   ensures \result == 0.0;
      @ also
      @   requires isPositiveZero(a);
      @   ensures isPositiveZero(\result);
      @ also
      @   requires isNegativeZero(a);
      @   ensures isNegativeZero(\result);
      @ also
      @   requires !Double.isNaN(a);
      @   ensures -PI/2 <= \result && \result <= PI/2;
      @   ensures (* result within 1 ulp of exact result *);
      @ |}
      @*/
    public static /*@ pure @*/ double atan(double a);

    /*@ public normal_behavior
      @   ensures Double.isNaN(angdeg) <==> Double.isNaN(\result);
      @*/
    public static /*@ pure @*/ double toRadians(double angdeg);

    /*@ public normal_behavior
      @   ensures Double.isNaN(angrad) <==> Double.isNaN(\result);
      @*/
    public static /*@ pure @*/ double toDegrees(double angrad);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(a);
      @   ensures Double.isNaN(\result);
      @ also
      @   requires a == Double.POSITIVE_INFINITY;
      @   ensures \result == Double.POSITIVE_INFINITY;
      @ also
      @   requires a == Double.NEGATIVE_INFINITY;
      @   ensures isPositiveZero(\result);
      @ also
      @   requires isFinite(a);
      @   ensures (* result within 1 ulp of exact result *);
      @ |}
      @*/
    public static /*@ pure @*/ double exp(double a);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(a) || a < 0.0;
      @   ensures Double.isNaN(\result);
      @ also
      @   requires a == Double.POSITIVE_INFINITY;
      @   ensures \result == Double.POSITIVE_INFINITY;
      @ also
      @   requires a == 0.0;  // positive or negative zero
      @   ensures \result == Double.NEGATIVE_INFINITY;
      @ also
      @   requires a >= 0.0 && a < Double.POSITIVE_INFINITY;
      @   ensures (* result within 1 ulp of exact result *);
      @ |}
      @*/
    public static /*@ pure @*/ double log(double a);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(a) || a < 0.0;
      @   ensures Double.isNaN(\result);
      @ also
      @   requires a == Double.POSITIVE_INFINITY;
      @   ensures \result == Double.POSITIVE_INFINITY;
      @ also
      @   requires isPositiveZero(a);
      @   ensures isPositiveZero(\result);
      @ also
      @   requires isNegativeZero(a);
      @   ensures isNegativeZero(\result);
      @ also
      @	  requires a > 0.0 && a < Double.POSITIVE_INFINITY;
      @   ensures close(a, \result * \result, 2.0E-16);
      @ |}
      @*/
    public static /*@ pure @*/ double sqrt(double a);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(f1) || Double.isNaN(f2) 
      @         || Double.isInfinite(f1) || f2 == 0.0;
      @   ensures Double.isNaN(\result);
      @ also
      @   requires !Double.isInfinite(f1) && Double.isInfinite(f2);
      @   ensures \result == f1;
      @ also
      @   requires f1 == Double.MAX_VALUE && f2 == Double.MIN_VALUE;
      @   ensures \result == 0.0;
      @ also
      @   ensures isPositiveZero(\result) ==> isPositiveZero(f1) || 0.0 < f1; 
      @   ensures isNegativeZero(\result) ==> isNegativeZero(f1) || f1 < 0.0;
      @   ensures 
      @   (* The remainder value is mathematically equal to 
      @      <code>f1&nbsp;-&nbsp;f2</code>&nbsp;&times;&nbsp;<i>n</i>,
      @      where <i>n</i> is the mathematical integer closest to the exact 
      @      mathematical value of the quotient <code>f1/f2</code>, and if two 
      @      mathematical integers are equally close to <code>f1/f2</code>, 
      @      then <i>n</i> is the integer that is even. *);
      @ |}
      @*/
    public static /*@ pure @*/ double IEEEremainder(double f1, double f2);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(a) || Double.isInfinite(a) || a == 0.0;
      @   ensures \result == a;
      @ also
      @   requires -1.0 < a && a < 0.0;
      @   ensures isNegativeZero(\result);
      @ also 
      @   requires a == rint(a);
      @   ensures \result == a;
      @ also
      @   requires isFinite(a) && a != 0.0;
      @   ensures isFinite(a);
      @   ensures \result == rint(\result);
      @   ensures a <= \result;
      @   ensures (\forall double d; a < d & d < \result; rint(d) != d);
      @   ensures \result == -floor(-a);
      @ |}
      @*/
    public static /*@ pure @*/ double ceil(double a);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(a) || Double.isInfinite(a) || a == 0.0;
      @   ensures \result == a;
      @ also 
      @   requires a == rint(a);
      @   ensures \result == a;
      @ also
      @   requires isFinite(a) && a != 0.0;
      @   ensures isFinite(\result);
      @   ensures \result == rint(\result);
      @   ensures \result <= a;
      @   ensures (\forall double d; \result < d && d < a; rint(d) != d);
      @ |}
      @*/
    public static /*@ pure @*/ double floor(double a);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(a) || Double.isInfinite(a) || a == 0.0;
      @   ensures \result == a;
      @ also
      @   requires isFinite(a) && a != 0.0;
      @   ensures isFinite(\result);
      @   ensures (* \result is mathematical integer closest to a *);
      @ |}
      @*/
    public static /*@ pure @*/ double rint(double a);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(y) || Double.isNaN(x);
      @   ensures Double.isNaN(\result);
      @ also
      @   requires (isPositiveZero(y) && x > 0.0)
      @         || (0.0 < y && y < Double.POSITIVE_INFINITY 
      @             && x == Double.POSITIVE_INFINITY);
      @   ensures isPositiveZero(\result);
      @ also
      @   requires (isNegativeZero(y) && x > 0.0)
      @         || (Double.NEGATIVE_INFINITY < y && y < 0.0
      @             && x == Double.POSITIVE_INFINITY);
      @   ensures isNegativeZero(\result);
      @ also
      @   requires (isPositiveZero(y) && x < 0.0)
      @         || (0.0 < y && y < Double.POSITIVE_INFINITY 
      @             && x == Double.NEGATIVE_INFINITY);
      @   ensures \result == PI;
      @ also
      @   requires (isNegativeZero(y) && x < 0.0)
      @         || (Double.NEGATIVE_INFINITY < y && y < 0.0
      @             && x == Double.NEGATIVE_INFINITY);
      @   ensures \result == -PI;
      @ also
      @   requires (y > 0.0 && x == 0.0)
      @         || (y == Double.POSITIVE_INFINITY
      @             && Double.NEGATIVE_INFINITY < x
      @             && x < Double.POSITIVE_INFINITY);
      @   ensures \result == PI/2.0;
      @ also
      @   requires (y < 0.0 && x == 0.0)
      @         || (y == Double.NEGATIVE_INFINITY
      @             && Double.NEGATIVE_INFINITY < x
      @             && x < Double.POSITIVE_INFINITY);
      @   ensures \result == -PI/2.0;
      @ also
      @   requires y == Double.POSITIVE_INFINITY 
      @         && x == Double.POSITIVE_INFINITY;
      @   ensures \result == PI/4.0;
      @ also
      @   requires y == Double.POSITIVE_INFINITY
      @         && x == Double.NEGATIVE_INFINITY;
      @   ensures \result == 3.0*PI/4.0;
      @ also
      @   requires y == Double.NEGATIVE_INFINITY
      @         && x == Double.POSITIVE_INFINITY;
      @   ensures \result == -PI/4.0;
      @ also
      @   requires y == Double.NEGATIVE_INFINITY
      @         && x == Double.NEGATIVE_INFINITY;
      @   ensures \result == -3.0*PI/4.0;
      @ also
      @   ensures (* result within 2 ulp of exact result *);
      @ |}
      @*/
    public static /*@ pure @*/ double atan2(double y, double x);

    /*@ public normal_behavior
      @ {|
      @   requires b == 0.0;
      @   ensures \result == 1.0;
      @ also
      @   requires b == 1.0;
      @   ensures \result == a;
      @ also 
      @   requires Double.isNaN(b);
      @   ensures Double.isNaN(\result);
      @ also
      @   requires Double.isNaN(a) && b != 0.0;
      @   ensures Double.isNaN(\result);
      @ also
      @   requires (1.0 < abs(a) && b == Double.POSITIVE_INFINITY)
      @         || (abs(a) < 1.0 && b == Double.NEGATIVE_INFINITY);
      @   ensures \result == Double.POSITIVE_INFINITY;
      @ also
      @   requires (1.0 < abs(a) && b == Double.NEGATIVE_INFINITY)
      @         || (abs(a) < 1.0 && b == Double.POSITIVE_INFINITY);
      @   ensures isPositiveZero(\result);
      @ also
      @   requires abs(a) == 1.0 && Double.isInfinite(b);
      @   ensures Double.isNaN(\result);
      @ also
      @   requires (isPositiveZero(a) && 0.0 < b)
      @         || (a == Double.POSITIVE_INFINITY && b < 0.0);
      @   ensures isPositiveZero(\result);
      @ also 
      @   requires (isPositiveZero(a) && b < 0.0)
      @         || (a == Double.POSITIVE_INFINITY && 0.0 < b);
      @   ensures \result == Double.POSITIVE_INFINITY;
      @ also
      @   requires (isNegativeZero(a) && 0.0 < b && !isFiniteOdd(b))
      @         || (a == Double.NEGATIVE_INFINITY && b < 0.0 && !isFiniteOdd(b));
      @   ensures isPositiveZero(\result);
      @ also
      @   requires (isNegativeZero(a) && 0.0 < b && isFiniteOdd(b))
      @         || (a == Double.NEGATIVE_INFINITY && b < 0.0 && isFiniteOdd(b));
      @   ensures isNegativeZero(\result);
      @ also
      @   requires (isNegativeZero(a) && b < 0.0 && !isFiniteOdd(b))
      @         || (a == Double.NEGATIVE_INFINITY && 0.0 < b && !isFiniteOdd(b));
      @   ensures \result == Double.POSITIVE_INFINITY;
      @ also
      @   requires (isNegativeZero(a) && b < 0.0 && isFiniteOdd(b))
      @         || (a == Double.NEGATIVE_INFINITY && 0.0 < b && isFiniteOdd(b));
      @   ensures \result == Double.NEGATIVE_INFINITY;
      @ also 
      @   requires !Double.isInfinite(a) && a < 0.0;
      @   ensures isFiniteEven(b) ==> \result == pow(abs(a), b);
      @   ensures isFiniteOdd(b) ==> \result == -pow(abs(a), b);
      @   ensures !Double.isInfinite(b) && b != rint(b) ==> Double.isNaN(\result);
      @   ensures (* result is within 1 ulp of exact result *);
      @ also
      @   requires a == rint(a) && b == rint(b);
      @   ensures 
      @     (* result is exactly equal to the mathematical result of raising
      @        a to the b power if that result can be represented exactly as
      @        a double value *);
      @   ensures (* result is within 1 ulp of exact result *);
      @ |}
      @*/
    public static /*@ pure @*/ double pow(double a, double b);

    /*@ public normal_behavior
      @ {|
      @   requires Float.isNaN(a);
      @   ensures \result == 0;  // NOTE THIS NON-INTUITIVE BEHAVIOR
      @ also
      @   requires a == Float.NEGATIVE_INFINITY || a <= Integer.MIN_VALUE;
      @   ensures \result == Integer.MIN_VALUE;
      @ also
      @   requires a == Float.POSITIVE_INFINITY || a >= Integer.MAX_VALUE;
      @   ensures \result == Integer.MAX_VALUE;
      @ also
      @   requires Integer.MIN_VALUE < a && a < Integer.MAX_VALUE;
      @   ensures \result == (int) Math.floor(a + 0.5f);
      @ |}
      @*/
    public static /*@ pure @*/ int round(float a);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(a);
      @   ensures \result == 0;  // NOTE THIS NON-INTUITIVE BEHAVIOR
      @ also
      @   requires a == Double.NEGATIVE_INFINITY || a <= Long.MIN_VALUE;
      @   ensures \result == Long.MIN_VALUE;
      @ also
      @   requires a == Double.POSITIVE_INFINITY || a >= Long.MAX_VALUE;
      @   ensures \result == Long.MAX_VALUE;
      @ also
      @   requires Long.MIN_VALUE < a && a < Long.MAX_VALUE;
      @   ensures \result == (long) Math.floor(a + 0.5d);
      @ |}
      @*/ 
    public static /*@ pure @*/ long round(double a);

    // lightweight spec case because we don't want or need to reason
    // about how Math generates random numbers
    //@ ensures 0.0 <= \result && \result < 1.0;
    public static double random();

    /*@ public normal_behavior
      @ {|
      @   requires a == Integer.MIN_VALUE;
      @   ensures \result == Integer.MIN_VALUE;
      @ also
      @   requires 0 <= a;
      @   ensures \result == a;
      @ also
      @   requires a < 0 && a != Integer.MIN_VALUE;
      @   ensures \result == -a; 
      @ also
      @   ensures_redundantly (\result != Integer.MIN_VALUE) ==> 0 <= \result;
      @ |}
      @*/
    public static /*@ pure @*/ int abs(int a);

    /*@ public normal_behavior
      @ {|
      @   requires a == Long.MIN_VALUE;
      @   ensures \result == Long.MIN_VALUE;
      @ also
      @   requires 0 <= a;
      @   ensures \result == a;
      @ also
      @   requires a < 0 && a != Long.MIN_VALUE;
      @   ensures \result == -a;
      @ also
      @   ensures_redundantly (\result != Long.MIN_VALUE) ==> 0 <= \result;
      @ |}
      @*/
    public static /*@ pure @*/ long abs(long a);

    /*@ public normal_behavior
      @ {|
      @   requires Float.isNaN(a);
      @   ensures Float.isNaN(\result);
      @ also
      @   requires a == 0.0;
      @   ensures isPositiveZero(\result);
      @ also
      @   requires Float.isInfinite(a);
      @   ensures \result == Float.POSITIVE_INFINITY;
      @ also
      @   requires 0.0 < a;
      @   ensures \result == a;
      @ also
      @   requires a < 0.0;
      @   ensures \result == -a;
      @ also
      @   ensures_redundantly !Float.isNaN(a) ==> 0.0f <= \result;
      @   ensures_redundantly 
      @     \result == Float.intBitsToFloat(0x7fffffff & Float.floatToIntBits(a));
      @ |}
      @*/
    public static /*@ pure @*/ float abs(float a);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(a);
      @   ensures Double.isNaN(\result);
      @ also
      @   requires a == 0.0; 
      @   ensures isPositiveZero(\result);
      @ also
      @   requires Double.isInfinite(a);
      @   ensures \result == Double.POSITIVE_INFINITY;
      @ also
      @   requires 0.0 < a;
      @   ensures \result == a;
      @ also
      @   requires a < 0.0;
      @   ensures \result == -a;
      @ also
      @   ensures_redundantly !Double.isNaN(a) ==> 0.0 <= \result;
      @   ensures_redundantly
      @     \result == Double.longBitsToDouble((Double.doubleToLongBits(a)<<1)>>>1);
      @ |}
      @*/
    public static /*@ pure @*/ double abs(double a);

    /*@ public normal_behavior
      @ {|
      @   requires a <= b;
      @   ensures \result == b;
      @ also
      @   requires b <= a;
      @   ensures \result == a;
      @ also
      @   ensures_redundantly a <= \result && b <= \result;
      @   ensures_redundantly \result == a || \result == b;
      @ |}
      @*/
    public static /*@ pure @*/ int max(int a, int b);

    /*@ public normal_behavior
      @ {|
      @   requires a <= b;
      @   ensures \result == b;
      @ also
      @   requires b <= a;
      @   ensures \result == a;
      @ also
      @   ensures_redundantly a <= \result && b <= \result;
      @   ensures_redundantly \result == a || \result == b;
      @ |}
      @*/
    public static /*@ pure @*/ long max(long a, long b);

    /*@ public normal_behavior
      @ {|
      @   requires Float.isNaN(a) || Float.isNaN(b);
      @   ensures Float.isNaN(\result);
      @ also
      @   requires !Float.isNaN(a) && !Float.isNaN(b);
      @   {|
      @     requires new Float(a).compareTo(new Float(b)) <= 0.0;
      @     ensures \result == b;
      @   also
      @     requires 0.0 <= new Float(a).compareTo(new Float(b));
      @     ensures \result == a;
      @   |}
      @ |}
      @*/
    public static /*@ pure @*/ float max(float a, float b);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(a) || Double.isNaN(b);
      @   ensures Double.isNaN(\result);
      @ also
      @   requires !Double.isNaN(a) && !Double.isNaN(b);
      @   {|
      @     requires new Double(a).compareTo(new Double(b)) <= 0.0;
      @     ensures \result == b;
      @   also
      @     requires 0.0 <= new Double(a).compareTo(new Double(b));
      @     ensures \result == a;
      @   |}
      @ |}
      @*/
    public static /*@ pure @*/ double max(double a, double b);

    /*@ public normal_behavior
      @ {|
      @   requires a <= b;
      @   ensures \result == a;
      @ also
      @   requires b <= a;
      @   ensures \result == b;
      @ also
      @   ensures_redundantly \result <= a && \result <= b;
      @   ensures_redundantly \result == a || \result == b;
      @ |}
      @*/
    public static /*@ pure @*/ int min(int a, int b);

    /*@ public normal_behavior
      @ {|
      @   requires a <= b;
      @   ensures \result == a;
      @ also
      @   requires b <= a;
      @   ensures \result == b;
      @ also
      @   ensures_redundantly \result <= a && \result <= b;
      @   ensures_redundantly \result == a || \result == b;
      @ |}
      @*/
    public static /*@ pure @*/ long min(long a, long b);

    /*@ public normal_behavior
      @ {|
      @   requires Float.isNaN(a) || Float.isNaN(b);
      @   ensures Float.isNaN(\result);
      @ also
      @   requires !Float.isNaN(a) && !Float.isNaN(b);
      @   {|
      @     requires new Float(a).compareTo(new Float(b)) <= 0.0;
      @     ensures \result == a;
      @   also
      @     requires 0.0 <= new Float(a).compareTo(new Float(b));
      @     ensures \result == b;
      @   |}
      @ |}
      @*/
    public static /*@ pure @*/ float min(float a, float b);

    /*@ public normal_behavior
      @ {|
      @   requires Double.isNaN(a) || Double.isNaN(b);
      @   ensures Double.isNaN(\result);
      @ also
      @   requires !Double.isNaN(a) && !Double.isNaN(b);
      @   {|
      @     requires new Double(a).compareTo(new Double(b)) <= 0.0;
      @     ensures \result == a;
      @   also
      @     requires 0.0 <= new Double(a).compareTo(new Double(b));
      @     ensures \result == b;
      @   |}
      @ |}
      @*/
    public static /*@ pure @*/ double min(double a, double b);
    
    // model methods to help make some of the special cases
    // easier to deal with
    /*@ public static model pure boolean isPositiveZero(double a) {
	      return java.lang.Double.isPositiveZero(a);
        }
	
        public static model pure boolean isNegativeZero(double a) {
	      return java.lang.Double.isNegativeZero(a);
        }
    
        public static model pure boolean isPositiveZero(float a) {
	      return java.lang.Float.isPositiveZero(a);
        }
	
        public static model pure boolean isNegativeZero(float a) {
	      return java.lang.Float.isNegativeZero(a);
        }
    
        public static model pure boolean isFinite(double a) {
          return Double.NEGATIVE_INFINITY < a && 
                 a < Double.POSITIVE_INFINITY;
        }

        public static model pure boolean isFiniteOdd(double a) {
          if ((a - 2.0 * floor(a / 2.0)) == 1.0 && isFinite(a)) {
            return true;
          } else {
            return false;
          }
        }
     
       public static model pure boolean isFiniteEven(double a) {
          if (IEEEremainder(a, 2.0) == 0.0 && isFinite(a)) {
            return true;
          } else {
            return false;
          }
        }

       public static model pure boolean close(double a, double b,
                                              double eps) {
         return abs(a - b) <= max(abs(a), abs(b)) * eps;
       }
    @*/
}
